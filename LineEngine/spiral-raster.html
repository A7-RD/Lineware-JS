<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stroke Raster</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <main>
    <header>
      <h1>Stroke Raster</h1>
      <p>Convert an image into layered stroke rasters with controllable direction, spacing, and thickness.</p>
    </header>

    <div class="control-groups">
      <section class="panel">
        <h2>Raster Controls</h2>
        <div class="controls">
          <label>
            Choose image
            <input id="image-input" type="file" accept="image/*">
          </label>
          <label>
            Blur radius
            <input id="blur-radius" type="number" min="0" max="20" step="0.5" value="0">
          </label>
          <label>
            Contrast boost
            <input id="contrast" type="range" min="0" max="1.5" step="0.05" value="0.4">
          </label>
        </div>
      </section>

      <section class="panel">
        <h2>Vector Controls</h2>
        <div class="controls">
          <label>
            Line direction (deg)
            <input id="direction-degrees" type="number" min="-360" max="360" step="1" value="0">
          </label>
          <div class="row">
            <label>
              Min thickness
              <input id="min-thickness" type="number" min="0.5" max="10" step="0.1" value="2">
            </label>
            <label>
              Max thickness
              <input id="max-thickness" type="number" min="0" max="50" step="1" value="14">
            </label>
          </div>
          <label>
            Line spacing
            <input id="line-spacing" type="number" min="0.5" max="20" step="0.25" value="4">
          </label>
          <label>
            Segment length
            <input id="segment-length" type="number" min="2" max="120" step="1" value="12">
          </label>
          <label>
            Stroke cap
            <select id="stroke-cap">
              <option value="round">Round</option>
              <option value="butt">Flat</option>
            </select>
          </label>
          <button id="export-svg" type="button">Export SVG</button>
        </div>
      </section>
    </div>

    <section class="panel">
      <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
        <h2 style="margin:0;">Canvas View</h2>
        <div class="view-toggle">
          <input type="radio" name="view-mode" id="view-vector" value="vector" checked>
          <label for="view-vector">Vector Output</label>
          <input type="radio" name="view-mode" id="view-raster" value="raster">
          <label for="view-raster">Raster Input</label>
        </div>
      </div>
      <canvas id="paper-canvas"></canvas>
      <div style="margin-top: 12px; display: flex; gap: 12px;">
        <button id="copy-svg" type="button" class="secondary">Copy SVG To Clipboard</button>
      </div>
    </section>

    <footer>
      Tip: Darker areas produce thicker strokes. Try changing direction or spacing to mimic different engravings.
    </footer>
  </main>

  <script>
    const canvas = document.getElementById('paper-canvas');
    const ctx = canvas.getContext('2d');
    const imageCanvas = document.createElement('canvas');
    const imageCtx = imageCanvas.getContext('2d');

    const DEFAULT_IMAGE = './stainless-steel-phillips-flat-head-screw.jpg';

    const state = {
      imageSource: null,
      imageElement: null,
      imageData: null,
      redrawHandle: null,
      viewMode: 'vector',
      lastSegments: [],
      lastStrokeCap: 'round',
      lastDimensions: { width: 0, height: 0 }
    };

    const inputs = {
      file: document.getElementById('image-input'),
      blur: document.getElementById('blur-radius'),
      contrast: document.getElementById('contrast'),
      directionDegrees: document.getElementById('direction-degrees'),
      minThickness: document.getElementById('min-thickness'),
      maxThickness: document.getElementById('max-thickness'),
      lineSpacing: document.getElementById('line-spacing'),
      segmentLength: document.getElementById('segment-length'),
      strokeCap: document.getElementById('stroke-cap'),
      viewToggles: document.querySelectorAll('input[name="view-mode"]'),
      exportButton: document.getElementById('export-svg'),
      copyButton: document.getElementById('copy-svg')
    };

    function scheduleRedraw() {
      if (!state.imageData) {
        return;
      }
      if (state.redrawHandle) {
        cancelAnimationFrame(state.redrawHandle);
      }
      state.redrawHandle = requestAnimationFrame(() => {
        state.redrawHandle = null;
        drawStrokeRaster();
      });
    }

    function loadImage(file) {
      const reader = new FileReader();
      reader.addEventListener('load', (event) => {
        setImageSource(event.target.result);
      });
      reader.readAsDataURL(file);
    }

    function setImageSource(source) {
      state.imageSource = source;
      loadImageElement();
    }

    function loadImageElement() {
      if (!state.imageSource) {
        return;
      }

      const image = new Image();
      if (typeof state.imageSource === 'string' && /^https?:\/\//i.test(state.imageSource)) {
        image.crossOrigin = 'anonymous';
      }

      image.onload = () => {
        state.imageElement = image;
        redrawImageData();
      };

      image.onerror = () => {
        console.error('Failed to load image:', state.imageSource);
        state.imageElement = null;
        state.imageData = null;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      };

      image.src = state.imageSource;
    }

    function redrawImageData() {
      if (!state.imageElement) {
        return;
      }

      const width = canvas.width;
      const height = canvas.height;

      if (!width || !height) {
        return;
      }

      imageCanvas.width = width;
      imageCanvas.height = height;
      imageCtx.clearRect(0, 0, width, height);

      const blurRadius = Math.max(0, parseFloat(inputs.blur.value) || 0);
      imageCtx.filter = blurRadius > 0 ? `blur(${blurRadius}px)` : 'none';

      const { width: imgW, height: imgH } = state.imageElement;
      const scale = Math.min(width / imgW, height / imgH);
      const drawWidth = imgW * scale;
      const drawHeight = imgH * scale;
      const dx = (width - drawWidth) / 2;
      const dy = (height - drawHeight) / 2;

      imageCtx.fillStyle = '#fff';
      imageCtx.fillRect(0, 0, width, height);
      imageCtx.drawImage(state.imageElement, dx, dy, drawWidth, drawHeight);
      imageCtx.filter = 'none';

      try {
        state.imageData = imageCtx.getImageData(0, 0, width, height);
      } catch (error) {
        console.error('Unable to read image pixels. If the image is remote, ensure it allows CORS.', error);
        state.imageData = null;
        ctx.clearRect(0, 0, width, height);
        return;
      }
      scheduleRedraw();
    }

    function adjustCanvasSize() {
      const rect = canvas.getBoundingClientRect();
      const width = Math.max(1, Math.round(rect.width));
      const height = Math.max(1, Math.round(rect.height));
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
      redrawImageData();
    }

    function sampleBrightness(x, y) {
      if (!state.imageData) {
        return 1;
      }
      const width = state.imageData.width;
      const height = state.imageData.height;
      const ix = Math.min(width - 1, Math.max(0, Math.round(x)));
      const iy = Math.min(height - 1, Math.max(0, Math.round(y)));
      const index = (iy * width + ix) * 4;
      const data = state.imageData.data;
      const r = data[index] / 255;
      const g = data[index + 1] / 255;
      const b = data[index + 2] / 255;
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }

    function drawStrokeRaster() {
      if (!state.imageData) {
        return;
      }

      const width = canvas.width;
      const height = canvas.height;
      const params = {
        minThickness: Math.max(0.1, parseFloat(inputs.minThickness.value) || 2),
        maxThicknessValue: parseFloat(inputs.maxThickness.value),
        lineSpacing: Math.max(0.5, parseFloat(inputs.lineSpacing.value) || 4),
        segmentLength: Math.max(1, parseFloat(inputs.segmentLength.value) || 12),
        contrastBoost: Math.max(0, parseFloat(inputs.contrast.value) || 0),
        directionDegrees: Number.isFinite(parseFloat(inputs.directionDegrees.value))
          ? parseFloat(inputs.directionDegrees.value)
          : 0,
        strokeCap: inputs.strokeCap.value === 'butt' ? 'butt' : 'round'
      };

      const maxThickness = Number.isFinite(params.maxThicknessValue)
        ? Math.max(params.minThickness, params.maxThicknessValue)
        : params.minThickness;

      const segments = collectSegments({
        width,
        height,
        minThickness: params.minThickness,
        maxThickness,
        lineSpacing: params.lineSpacing,
        segmentLength: params.segmentLength,
        contrastBoost: params.contrastBoost,
        directionDegrees: params.directionDegrees
      });

      state.lastSegments = segments;
      state.lastStrokeCap = params.strokeCap;
      state.lastDimensions = { width, height };

      ctx.clearRect(0, 0, width, height);

      if (state.viewMode === 'raster') {
        ctx.putImageData(state.imageData, 0, 0);
        return;
      }

      ctx.lineJoin = params.strokeCap === 'butt' ? 'miter' : 'round';
      ctx.lineCap = params.strokeCap;
      ctx.strokeStyle = '#111';

      for (const segment of segments) {
        ctx.lineWidth = segment.thickness;
        ctx.beginPath();
        ctx.moveTo(segment.x0, segment.y0);
        ctx.lineTo(segment.x1, segment.y1);
        ctx.stroke();
      }
    }

    function clipLineAgainstRect(px, py, dx, dy, width, height) {
      const EPS = 1e-6;
      let tMin = -Infinity;
      let tMax = Infinity;

      const checks = [
        { p: -dx, q: px },
        { p: dx, q: width - px },
        { p: -dy, q: py },
        { p: dy, q: height - py }
      ];

      for (const { p, q } of checks) {
        if (Math.abs(p) < EPS) {
          if (q < 0) {
            return null;
          }
          continue;
        }
        const t = q / p;
        if (p < 0) {
          if (t > tMin) {
            tMin = t;
          }
        } else {
          if (t < tMax) {
            tMax = t;
          }
        }
      }

      if (tMin > tMax) {
        return null;
      }

      if (!isFinite(tMin) || !isFinite(tMax)) {
        const corners = [
          [0, 0],
          [width, 0],
          [0, height],
          [width, height]
        ];
        let minProj = Infinity;
        let maxProj = -Infinity;
        for (const [cx, cy] of corners) {
          const proj = (cx - px) * dx + (cy - py) * dy;
          if (proj < minProj) {
            minProj = proj;
          }
          if (proj > maxProj) {
            maxProj = proj;
          }
        }
        if (minProj === Infinity || maxProj === -Infinity) {
          return null;
        }
        tMin = minProj;
        tMax = maxProj;
      }

      return [tMin, tMax];
    }

function collectSegments({
  width,
  height,
  minThickness,
  maxThickness,
  lineSpacing,
  segmentLength,
  contrastBoost,
  directionDegrees
}) {
  const segments = [];
  const thicknessRange = Math.max(0, maxThickness - minThickness);
  const adjustBrightness = (value) =>
    Math.min(1, Math.max(0, 0.5 + (value - 0.5) * (1 + contrastBoost)));
  const thicknessFor = (brightness) =>
    Math.max(0.1, minThickness + (1 - brightness) * thicknessRange);

  let angle = Number.isFinite(directionDegrees) ? directionDegrees : 0;
  angle = ((angle % 360) + 360) % 360; // normalize 0-360
  const radians = angle * Math.PI / 180;
  const dirX = Math.cos(radians);
  const dirY = Math.sin(radians);

  const traceLines = (dirXValue, dirYValue) => {
    const dirLength = Math.hypot(dirXValue, dirYValue);
    if (dirLength === 0) {
      return;
    }

    const step = segmentLength;
    const ux = dirXValue / dirLength;
    const uy = dirYValue / dirLength;
    const nx = -uy;
    const ny = ux;
    const spacing = Math.max(0.5, lineSpacing);
    const centerX = width / 2;
    const centerY = height / 2;
    const span = Math.abs(nx) * width + Math.abs(ny) * height;
    const lineCount = Math.ceil(span / spacing) + 4;

    for (let i = -lineCount; i <= lineCount; i++) {
      const offset = i * spacing;
      const baseX = centerX + nx * offset;
      const baseY = centerY + ny * offset;
      const bounds = clipLineAgainstRect(baseX, baseY, ux, uy, width, height);
      if (!bounds) {
        continue;
      }

      let [tMin, tMax] = bounds;
      if (!isFinite(tMin) || !isFinite(tMax) || tMax <= tMin) {
        continue;
      }

      let t = tMin;
      while (t < tMax) {
        const tEnd = Math.min(t + step, tMax);
        if (tEnd <= t) {
          break;
        }
        const mid = t + (tEnd - t) * 0.5;
        const sampleX = baseX + ux * mid;
        const sampleY = baseY + uy * mid;
        const brightness = adjustBrightness(sampleBrightness(sampleX, sampleY));
        const thickness = thicknessFor(brightness);

        segments.push({
          x0: baseX + ux * t,
          y0: baseY + uy * t,
          x1: baseX + ux * tEnd,
          y1: baseY + uy * tEnd,
          thickness
        });

        t = tEnd;
      }
    }
  };

  traceLines(dirX, dirY);

  return segments;
}
    inputs.file.addEventListener('change', (event) => {
      const [file] = event.target.files;
      if (file) {
        loadImage(file);
      }
    });

    inputs.directionDegrees.addEventListener('input', scheduleRedraw);
    inputs.directionDegrees.addEventListener('change', scheduleRedraw);
    inputs.minThickness.addEventListener('input', scheduleRedraw);
    inputs.maxThickness.addEventListener('input', scheduleRedraw);
    inputs.lineSpacing.addEventListener('input', scheduleRedraw);
    inputs.segmentLength.addEventListener('input', scheduleRedraw);
    inputs.contrast.addEventListener('input', scheduleRedraw);
    inputs.strokeCap.addEventListener('change', scheduleRedraw);
    inputs.strokeCap.addEventListener('input', scheduleRedraw);

    inputs.blur.addEventListener('input', redrawImageData);
    inputs.blur.addEventListener('change', redrawImageData);

    inputs.viewToggles.forEach((radio) => {
      radio.addEventListener('change', (event) => {
        if (event.target.checked) {
          state.viewMode = event.target.value;
          scheduleRedraw();
        }
      });
    });

    inputs.exportButton.addEventListener('click', () => exportSvg({ download: true }));
    inputs.copyButton.addEventListener('click', async () => {
      const svg = exportSvg({ download: false });
      if (!svg) {
        return;
      }
      try {
        await navigator.clipboard.writeText(svg);
      } catch (error) {
        console.error('Failed to copy SVG to clipboard:', error);
      }
    });

    window.addEventListener('resize', adjustCanvasSize);

    adjustCanvasSize();
    if (DEFAULT_IMAGE) {
      setImageSource(DEFAULT_IMAGE);
    }

    document.addEventListener('paste', (event) => {
      const items = event.clipboardData?.items;
      if (!items) {
        return;
      }
      for (const item of items) {
        if (item.kind === 'file' && item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (file) {
            loadImage(file);
            event.preventDefault();
            return;
          }
        } else if (item.kind === 'string' && item.type === 'text/plain') {
          item.getAsString((text) => {
            if (/^data:image\/[a-zA-Z]+;base64,/.test(text) || /^https?:\/\//i.test(text)) {
              setImageSource(text);
            }
          });
        }
      }
    });

    function exportSvg({ download }) {
      if (!state.lastSegments.length) {
        console.warn('No vector data to export. Ensure the image has been processed.');
        return null;
      }

      const { width, height } = state.lastDimensions;
      if (!width || !height) {
        console.warn('Canvas dimensions unavailable for export.');
        return null;
      }

      const strokeCap = state.lastStrokeCap;
      const precision = (value) => Number.parseFloat(value).toFixed(2);
      const lines = state.lastSegments
        .map((segment) => {
          const x1 = precision(segment.x0);
          const y1 = precision(segment.y0);
          const x2 = precision(segment.x1);
          const y2 = precision(segment.y1);
          const sw = precision(Math.max(0.1, segment.thickness));
          return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke-width="${sw}" />`;
        })
        .join('\n    ');

      const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <g stroke="#111" stroke-linecap="${strokeCap}" fill="none">
    ${lines}
  </g>
</svg>`;

      if (download) {
        const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'stroke-raster.svg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      return svg;
    }
  </script>
</body>
</html>
