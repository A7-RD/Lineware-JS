<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stroke Raster</title>
  <link rel="stylesheet" href="spiral-raster.css">
</head>
<body>
  <main>
    <header>
      <h1>Stroke Raster</h1>
      <p>Convert an image into layered stroke rasters with controllable direction, spacing, and thickness.</p>
    </header>

    <div class="control-groups">
      <section class="panel">
        <h2>Raster Controls</h2>
        <div class="controls">
          <label>
            Choose image
            <input id="image-input" type="file" accept="image/*">
          </label>
          <label>
            Contrast boost
            <input id="contrast" type="range" min="0" max="1.5" step="0.05" value="0.4">
          </label>
          <label>
            Blur radius
            <input id="blur-radius" type="range" min="0" max="30" step="1" value="0">
          </label>
          <label>
            Levels of grey
            <input id="levels" type="number" min="2" max="10" step="1" value="4">
          </label>
        </div>
      </section>

      <section class="panel">
        <h2>Vector Controls</h2>
        <div class="controls">
          <label>
            Line direction (deg)
            <input id="direction-degrees" type="number" min="-360" max="360" step="1" value="0">
          </label>
          <label>
            Line spacing
            <input id="line-spacing" type="number" min="1" max="20" step="1" value="8">
          </label>
          <label>
            Segment length
            <input id="segment-length" type="number" min="1" max="120" step="1" value="12">
          </label>
          <div id="stroke-weights" class="stroke-weights"></div>
          <label>
            Stroke cap
            <select id="stroke-cap">
              <option value="round">Round</option>
              <option value="butt">Flat</option>
            </select>
          </label>
        </div>
      </section>
    </div>

    <section class="panel">
      <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
        <h2 style="margin:0;">Canvas View</h2>
        <button id="view-toggle" class="view-toggle" type="button" aria-label="Toggle raster view" aria-pressed="false">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path class="eye-open" d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle class="eye-open" cx="12" cy="12" r="3"></circle>
            <path class="eye-closed" d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <line class="eye-closed" x1="1" y1="1" x2="23" y2="23"></line>
          </svg>
        </button>
      </div>
      <canvas id="paper-canvas"></canvas>
      <div style="margin-top: 12px; display: flex; gap: 12px;">
        <button id="copy-svg" type="button" class="secondary">Copy SVG To Clipboard</button>
      </div>
    </section>

    <footer>
      Tip: Darker areas produce thicker strokes. Try changing direction or spacing to mimic different engravings.
    </footer>
  </main>

  <script>
    const canvas = document.getElementById('paper-canvas');
    const ctx = canvas.getContext('2d');
    const imageCanvas = document.createElement('canvas');
    const imageCtx = imageCanvas.getContext('2d');

    const DEFAULT_IMAGE = './stainless-steel-phillips-flat-head-screw.jpg';

    const state = {
      imageSource: null,
      imageElement: null,
      imageData: null,
      redrawHandle: null,
      viewMode: 'vector',
      levels: 4,
      strokeWeights: [],
      lastSegments: [],
      lastStrokeCap: 'round',
      lastDimensions: { width: 0, height: 0 }
    };

    const inputs = {
      file: document.getElementById('image-input'),
      blur: document.getElementById('blur-radius'),
      contrast: document.getElementById('contrast'),
      levels: document.getElementById('levels'),
      directionDegrees: document.getElementById('direction-degrees'),
      lineSpacing: document.getElementById('line-spacing'),
      segmentLength: document.getElementById('segment-length'),
      strokeCap: document.getElementById('stroke-cap'),
      strokeWeightsContainer: document.getElementById('stroke-weights'),
      viewToggleButton: document.getElementById('view-toggle'),
      copyButton: document.getElementById('copy-svg')
    };

    function scheduleRedraw() {
      if (!state.imageData) {
        return;
      }
      if (state.redrawHandle) {
        cancelAnimationFrame(state.redrawHandle);
      }
      state.redrawHandle = requestAnimationFrame(() => {
        state.redrawHandle = null;
        drawStrokeRaster();
      });
    }

    function clampLevels(value) {
      if (!Number.isFinite(value)) {
        return state.levels || 4;
      }
      return Math.min(10, Math.max(2, Math.round(value)));
    }

    function applyContrast(brightness, boost) {
      return Math.min(1, Math.max(0, 0.5 + (brightness - 0.5) * (1 + boost)));
    }

    function blurBrightnessValues(values, width, height, radius) {
      if (!Number.isFinite(radius) || radius <= 0) {
        return values;
      }

      radius = Math.min(50, Math.floor(radius));
      if (radius <= 0) {
        return values;
      }

      const windowSize = radius * 2 + 1;
      const totalPixels = values.length;
      const horizontal = new Float32Array(totalPixels);
      const blurred = new Float32Array(totalPixels);

      for (let y = 0; y < height; y++) {
        const rowOffset = y * width;
        let sum = 0;
        for (let x = -radius; x <= radius; x++) {
          const clampedX = Math.min(width - 1, Math.max(0, x));
          sum += values[rowOffset + clampedX];
        }
        for (let x = 0; x < width; x++) {
          horizontal[rowOffset + x] = sum / windowSize;
          const removeIndex = rowOffset + Math.max(0, x - radius);
          const addIndex = rowOffset + Math.min(width - 1, x + radius + 1);
          sum += values[addIndex] - values[removeIndex];
        }
      }

      for (let x = 0; x < width; x++) {
        let sum = 0;
        for (let y = -radius; y <= radius; y++) {
          const clampedY = Math.min(height - 1, Math.max(0, y));
          sum += horizontal[clampedY * width + x];
        }
        for (let y = 0; y < height; y++) {
          const index = y * width + x;
          blurred[index] = sum / windowSize;
          const removeY = Math.max(0, y - radius);
          const addY = Math.min(height - 1, y + radius + 1);
          sum += horizontal[addY * width + x] - horizontal[removeY * width + x];
        }
      }

      return blurred;
    }

    function updateStrokeWeightInputs(levels) {
      const container = inputs.strokeWeightsContainer;
      container.innerHTML = '';
      const existing = Array.isArray(state.strokeWeights) ? state.strokeWeights : [];
      const newWeights = [];

      for (let i = 0; i < levels; i++) {
        const defaultWeight = Number.isFinite(existing[i])
          ? existing[i]
          : Math.max(1, Math.round(1 + (levels - i - 1) * 0.5));

        const label = document.createElement('label');
        label.textContent = `GL${i + 1}`;

        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0';
        input.step = '1';
        input.value = defaultWeight;
        input.dataset.levelIndex = String(i);
        input.addEventListener('input', handleStrokeWeightInput);
        input.addEventListener('change', handleStrokeWeightInput);

        label.appendChild(input);
        container.appendChild(label);
        newWeights.push(Math.max(0, defaultWeight));
      }

      state.strokeWeights = newWeights;
      scheduleRedraw();
    }

    function handleStrokeWeightInput(event) {
      const index = Number(event.target.dataset.levelIndex);
      const value = parseFloat(event.target.value);
      if (!Number.isFinite(index)) {
        return;
      }
      if (!Number.isFinite(value)) {
        return;
      }
      const clamped = Math.max(0, value);
      state.strokeWeights[index] = clamped;
      if (event.type === 'change') {
        event.target.value = clamped;
      }
      scheduleRedraw();
    }

    function handleLevelsChange(event) {
      const rawValue = inputs.levels.value;
      if (rawValue === '') {
        return;
      }

      const parsed = parseInt(rawValue, 10);
      if (!Number.isFinite(parsed)) {
        return;
      }

      if (event?.type === 'input' && parsed < 2) {
        return;
      }

      const levels = clampLevels(parsed);
      inputs.levels.value = levels;
      if (levels !== state.levels) {
        state.levels = levels;
      }
      updateStrokeWeightInputs(levels);
      redrawImageData();
    }

    state.levels = clampLevels(parseInt(inputs.levels.value, 10) || 4);
    inputs.levels.value = state.levels;
    updateStrokeWeightInputs(state.levels);

    function updateViewToggleButton() {
      const pressed = state.viewMode === 'raster';
      inputs.viewToggleButton.classList.toggle('is-raster', pressed);
      inputs.viewToggleButton.setAttribute('aria-pressed', String(pressed));
    }

    function loadImage(file) {
      const reader = new FileReader();
      reader.addEventListener('load', (event) => {
        setImageSource(event.target.result);
      });
      reader.readAsDataURL(file);
    }

    function setImageSource(source) {
      state.imageSource = source;
      loadImageElement();
    }

    function loadImageElement() {
      if (!state.imageSource) {
        return;
      }

      const image = new Image();
      if (typeof state.imageSource === 'string' && /^https?:\/\//i.test(state.imageSource)) {
        image.crossOrigin = 'anonymous';
      }

      image.onload = () => {
        state.imageElement = image;
        redrawImageData();
      };

      image.onerror = () => {
        console.error('Failed to load image:', state.imageSource);
        state.imageElement = null;
        state.imageData = null;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      };

      image.src = state.imageSource;
    }

    function redrawImageData() {
      if (!state.imageElement) {
        return;
      }

      const width = canvas.width;
      const height = canvas.height;

      if (!width || !height) {
        return;
      }

      imageCanvas.width = width;
      imageCanvas.height = height;
      imageCtx.clearRect(0, 0, width, height);
      imageCtx.filter = 'none';

      const blurRadius = Math.max(0, Math.round(parseFloat(inputs.blur.value) || 0));

      const { width: imgW, height: imgH } = state.imageElement;
      const scale = Math.min(width / imgW, height / imgH);
      const drawWidth = imgW * scale;
      const drawHeight = imgH * scale;
      const dx = (width - drawWidth) / 2;
      const dy = (height - drawHeight) / 2;

      imageCtx.fillStyle = '#fff';
      imageCtx.fillRect(0, 0, width, height);
      imageCtx.drawImage(state.imageElement, dx, dy, drawWidth, drawHeight);

      let imageData;
      try {
        imageData = imageCtx.getImageData(0, 0, width, height);
      } catch (error) {
        console.error('Unable to read image pixels. If the image is remote, ensure it allows CORS.', error);
        state.imageData = null;
        ctx.clearRect(0, 0, width, height);
        return;
      }

      const sourceData = imageData.data;
      const brightness = new Float32Array(width * height);
      for (let i = 0, j = 0; i < sourceData.length; i += 4, j++) {
        const r = sourceData[i] / 255;
        const g = sourceData[i + 1] / 255;
        const b = sourceData[i + 2] / 255;
        brightness[j] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
      }

      const blurredBrightness = blurRadius > 0
        ? blurBrightnessValues(brightness, width, height, blurRadius)
        : brightness;

      const levels = state.levels || clampLevels(parseInt(inputs.levels.value, 10) || 4);
      state.levels = levels;
      inputs.levels.value = levels;
      const contrastBoost = Math.max(0, parseFloat(inputs.contrast.value) || 0);
      const levelMax = Math.max(1, levels - 1);

      const data = imageData.data;

      for (let j = 0, i = 0; j < blurredBrightness.length; j++, i += 4) {
        const adjusted = applyContrast(blurredBrightness[j], contrastBoost);
        const levelIndex = Math.min(levelMax, Math.max(0, Math.round(adjusted * levelMax)));
        const quantBrightness = levelMax === 0 ? 0 : levelIndex / levelMax;
        const value = Math.round(quantBrightness * 255);
        data[i] = data[i + 1] = data[i + 2] = value;
      }

      imageCtx.putImageData(imageData, 0, 0);
      state.imageData = imageData;
      scheduleRedraw();
    }

    function adjustCanvasSize() {
      const rect = canvas.getBoundingClientRect();
      const width = Math.max(1, Math.round(rect.width));
      const height = Math.max(1, Math.round(rect.height));
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
      redrawImageData();
    }

    function sampleBrightness(x, y) {
      if (!state.imageData) {
        return 1;
      }
      const width = state.imageData.width;
      const height = state.imageData.height;
      const ix = Math.min(width - 1, Math.max(0, Math.round(x)));
      const iy = Math.min(height - 1, Math.max(0, Math.round(y)));
      const index = (iy * width + ix) * 4;
      const data = state.imageData.data;
      return data[index] / 255;
    }

    function drawStrokeRaster() {
      if (!state.imageData) {
        return;
      }

      const width = canvas.width;
      const height = canvas.height;
      const lineSpacing = Math.max(1, parseFloat(inputs.lineSpacing.value) || 8);
      const segmentLength = Math.max(1, parseFloat(inputs.segmentLength.value) || 12);
      const directionDegrees = Number.isFinite(parseFloat(inputs.directionDegrees.value))
        ? parseFloat(inputs.directionDegrees.value)
        : 0;
      const strokeCap = inputs.strokeCap.value === 'butt' ? 'butt' : 'round';

      const segments = collectSegments({
        width,
        height,
        lineSpacing,
        segmentLength,
        directionDegrees,
        strokeWeights: state.strokeWeights,
        levels: state.levels
      });

      state.lastSegments = segments;
      state.lastStrokeCap = strokeCap;
      state.lastDimensions = { width, height };

      ctx.clearRect(0, 0, width, height);

      if (state.viewMode === 'raster') {
        ctx.putImageData(state.imageData, 0, 0);
        return;
      }

      ctx.lineJoin = strokeCap === 'butt' ? 'miter' : 'round';
      ctx.lineCap = strokeCap;
      ctx.strokeStyle = '#111';

      for (const segment of segments) {
        ctx.lineWidth = segment.thickness;
        ctx.beginPath();
        ctx.moveTo(segment.x0, segment.y0);
        ctx.lineTo(segment.x1, segment.y1);
        ctx.stroke();
      }
    }

    function clipLineAgainstRect(px, py, dx, dy, width, height) {
      const EPS = 1e-6;
      let tMin = -Infinity;
      let tMax = Infinity;

      const checks = [
        { p: -dx, q: px },
        { p: dx, q: width - px },
        { p: -dy, q: py },
        { p: dy, q: height - py }
      ];

      for (const { p, q } of checks) {
        if (Math.abs(p) < EPS) {
          if (q < 0) {
            return null;
          }
          continue;
        }
        const t = q / p;
        if (p < 0) {
          if (t > tMin) {
            tMin = t;
          }
        } else {
          if (t < tMax) {
            tMax = t;
          }
        }
      }

      if (tMin > tMax) {
        return null;
      }

      if (!isFinite(tMin) || !isFinite(tMax)) {
        const corners = [
          [0, 0],
          [width, 0],
          [0, height],
          [width, height]
        ];
        let minProj = Infinity;
        let maxProj = -Infinity;
        for (const [cx, cy] of corners) {
          const proj = (cx - px) * dx + (cy - py) * dy;
          if (proj < minProj) {
            minProj = proj;
          }
          if (proj > maxProj) {
            maxProj = proj;
          }
        }
        if (minProj === Infinity || maxProj === -Infinity) {
          return null;
        }
        tMin = minProj;
        tMax = maxProj;
      }

      return [tMin, tMax];
    }

    function collectSegments({
      width,
      height,
      lineSpacing,
      segmentLength,
      directionDegrees,
      strokeWeights,
      levels
    }) {
      const segments = [];
      const weights = Array.isArray(strokeWeights) && strokeWeights.length > 0
        ? strokeWeights
        : [1];
      const levelsCount = Math.max(2, levels || weights.length || 2);
      const maxLevelIndex = levelsCount - 1;

      const angle = ((Number.isFinite(directionDegrees) ? directionDegrees : 0) % 360 + 360) % 360;
      const radians = angle * Math.PI / 180;
      const dirX = Math.cos(radians);
      const dirY = Math.sin(radians);

      const dirLength = Math.hypot(dirX, dirY);
      if (dirLength === 0) {
        return segments;
      }

      const step = Math.max(0.1, segmentLength);
      const spacing = Math.max(0.5, lineSpacing);
      const ux = dirX / dirLength;
      const uy = dirY / dirLength;
      const nx = -uy;
      const ny = ux;
      const centerX = width / 2;
      const centerY = height / 2;
      const span = Math.abs(nx) * width + Math.abs(ny) * height;
      const lineCount = Math.ceil(span / spacing) + 4;

      for (let i = -lineCount; i <= lineCount; i++) {
        const offset = i * spacing;
        const baseX = centerX + nx * offset;
        const baseY = centerY + ny * offset;
        const bounds = clipLineAgainstRect(baseX, baseY, ux, uy, width, height);
        if (!bounds) {
          continue;
        }

        let [tMin, tMax] = bounds;
        if (!isFinite(tMin) || !isFinite(tMax) || tMax <= tMin) {
          continue;
        }

        let t = tMin;
        while (t < tMax) {
          const tEnd = Math.min(t + step, tMax);
          if (tEnd <= t) {
            break;
          }
          const mid = t + (tEnd - t) * 0.5;
          const sampleX = baseX + ux * mid;
          const sampleY = baseY + uy * mid;
          const brightness = sampleBrightness(sampleX, sampleY);
          const levelIndex = Math.max(0, Math.min(maxLevelIndex, Math.round(brightness * maxLevelIndex)));
          const thickness = weights[levelIndex] ?? weights[weights.length - 1] ?? 1;

          segments.push({
            x0: baseX + ux * t,
            y0: baseY + uy * t,
            x1: baseX + ux * tEnd,
            y1: baseY + uy * tEnd,
            thickness
          });

          t = tEnd;
        }
      }

      return segments;
    }
    inputs.file.addEventListener('change', (event) => {
      const [file] = event.target.files;
      if (file) {
        loadImage(file);
      }
    });

    inputs.directionDegrees.addEventListener('input', scheduleRedraw);
    inputs.directionDegrees.addEventListener('change', scheduleRedraw);
    inputs.lineSpacing.addEventListener('input', scheduleRedraw);
    inputs.lineSpacing.addEventListener('change', scheduleRedraw);
    inputs.segmentLength.addEventListener('input', scheduleRedraw);
    inputs.segmentLength.addEventListener('change', scheduleRedraw);
    inputs.strokeCap.addEventListener('change', scheduleRedraw);

    inputs.blur.addEventListener('input', redrawImageData);
    inputs.blur.addEventListener('change', redrawImageData);
    inputs.contrast.addEventListener('input', redrawImageData);
    inputs.contrast.addEventListener('change', redrawImageData);
    inputs.levels.addEventListener('input', handleLevelsChange);
    inputs.levels.addEventListener('change', handleLevelsChange);

    inputs.viewToggleButton.addEventListener('click', () => {
      state.viewMode = state.viewMode === 'vector' ? 'raster' : 'vector';
      updateViewToggleButton();
      scheduleRedraw();
    });

    inputs.copyButton.addEventListener('click', async () => {
      const svg = exportSvg({ download: false });
      if (!svg) {
        return;
      }
      try {
        await navigator.clipboard.writeText(svg);
      } catch (error) {
        console.error('Failed to copy SVG to clipboard:', error);
      }
    });

    updateViewToggleButton();

    window.addEventListener('resize', adjustCanvasSize);

    adjustCanvasSize();
    if (DEFAULT_IMAGE) {
      setImageSource(DEFAULT_IMAGE);
    }

    document.addEventListener('paste', (event) => {
      const items = event.clipboardData?.items;
      if (!items) {
        return;
      }
      for (const item of items) {
        if (item.kind === 'file' && item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (file) {
            loadImage(file);
            event.preventDefault();
            return;
          }
        } else if (item.kind === 'string' && item.type === 'text/plain') {
          item.getAsString((text) => {
            if (/^data:image\/[a-zA-Z]+;base64,/.test(text) || /^https?:\/\//i.test(text)) {
              setImageSource(text);
            }
          });
        }
      }
    });

    function exportSvg({ download }) {
      if (!state.lastSegments.length) {
        console.warn('No vector data to export. Ensure the image has been processed.');
        return null;
      }

      const { width, height } = state.lastDimensions;
      if (!width || !height) {
        console.warn('Canvas dimensions unavailable for export.');
        return null;
      }

      const strokeCap = state.lastStrokeCap;
      const precision = (value) => Number.parseFloat(value).toFixed(2);
      const lines = state.lastSegments
        .map((segment) => {
          const x1 = precision(segment.x0);
          const y1 = precision(segment.y0);
          const x2 = precision(segment.x1);
          const y2 = precision(segment.y1);
          const sw = precision(Math.max(0.1, segment.thickness));
          return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke-width="${sw}" />`;
        })
        .join('\n    ');

      const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <g stroke="#111" stroke-linecap="${strokeCap}" fill="none">
    ${lines}
  </g>
</svg>`;

      if (download) {
        const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'stroke-raster.svg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      return svg;
    }
  </script>
</body>
</html>
