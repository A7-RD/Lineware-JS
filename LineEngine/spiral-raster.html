<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stroke Raster</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Geist:wght@200;300&family=Geist+Mono:wght@300&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="spiral-raster.css">
</head>
<body class="theme-dark">
  <main class="main-container">
    <!-- Preview Pane -->
    <section class="preview-pane">
      <div class="paper-canvas-container">
        <div id="canvas-wrapper" class="canvas-wrapper">
          <canvas id="paper-canvas"></canvas>
        </div>
      </div>
      <div class="canvas-controls">
        <p class="upload-text">
          <span class="upload-link">+ Upload</span>
          <span> or paste input image</span>
        </p>
        <button id="copy-svg" type="button" class="copy-svg-btn">Copy SVG</button>
      </div>
    </section>

    <!-- Controls Panel -->
    <div class="controls-panel">
      <!-- Raster Controls -->
      <section class="control-section">
        <div class="section-header">
          <h2>Raster Controls</h2>
          <button id="view-toggle" class="view-toggle" type="button" aria-label="Toggle raster view" aria-pressed="false">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path class="eye-open" d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
              <circle class="eye-open" cx="12" cy="12" r="3"></circle>
              <path class="eye-closed" d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
              <line class="eye-closed" x1="1" y1="1" x2="23" y2="23"></line>
            </svg>
          </button>
        </div>
        <div class="controls">
          <div class="slider-controls">
            <div class="slider-group">
              <label for="contrast">Contrast</label>
              <input id="contrast" type="range" min="0" max="1.5" step="0.05" value="0.4">
            </div>
            <div class="slider-group">
              <label for="blur-radius">Blur</label>
              <input id="blur-radius" type="range" min="0" max="30" step="1" value="0">
            </div>
          </div>
          <div class="number-control">
            <label for="levels">Grey Levels</label>
            <div class="number-input">
              <button type="button" class="number-btn minus" data-target="levels">-</button>
              <input id="levels" type="number" min="2" max="10" step="1" value="4">
              <button type="button" class="number-btn plus" data-target="levels">+</button>
            </div>
          </div>
        </div>
      </section>

      <!-- Vector Controls -->
      <section class="control-section">
        <h2>Vector Controls</h2>
        <div class="controls">
          <div class="vector-controls-row">
            <div class="number-control">
              <label for="direction-degrees">Angle</label>
              <div class="number-input">
                <button type="button" class="number-btn minus" data-target="direction-degrees">-</button>
                <input id="direction-degrees" type="number" min="-360" max="360" step="1" value="0">
                <button type="button" class="number-btn plus" data-target="direction-degrees">+</button>
              </div>
            </div>
            <div class="number-control">
              <label for="line-spacing">Space</label>
              <div class="number-input">
                <button type="button" class="number-btn minus" data-target="line-spacing">-</button>
                <input id="line-spacing" type="number" min="1" max="100" step="1" value="8">
                <button type="button" class="number-btn plus" data-target="line-spacing">+</button>
              </div>
            </div>
            <div class="number-control">
              <label for="segment-length">Length</label>
              <div class="number-input">
                <button type="button" class="number-btn minus" data-target="segment-length">-</button>
                <input id="segment-length" type="number" min="1" max="120" step="1" value="12">
                <button type="button" class="number-btn plus" data-target="segment-length">+</button>
              </div>
            </div>
            <div class="select-control">
              <label for="stroke-cap">Line Mode</label>
              <div class="select-input">
                <select id="stroke-cap">
                  <option value="round" selected>Round</option>
                  <option value="butt">Flat</option>
                </select>
              </div>
            </div>
          </div>
          <div class="stroke-levels">
            <label>Stroke Levels</label>
            <div id="stroke-weights" class="stroke-weights"></div>
          </div>
        </div>
      </section>
    </div>

    <!-- Hidden file input -->
    <input id="image-input" type="file" accept="image/*" style="display: none;">
  </main>

  <footer class="page-footer">
    <span class="footer-credit">created by: Ashton Henning</span>
    <button id="theme-toggle" class="theme-toggle" type="button" aria-pressed="false">
      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="5"></circle>
        <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"></path>
      </svg>
    </button>
  </footer>

  <script>
    const canvas = document.getElementById('paper-canvas');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    const ctx = canvas.getContext('2d');
    const imageCanvas = document.createElement('canvas');
    const imageCtx = imageCanvas.getContext('2d');

    const DEFAULT_IMAGE = './stainless-steel-phillips-flat-head-screw.jpg';

    const storedTheme = localStorage.getItem('strokeRasterTheme');
    const prefersLightScheme = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
    const initialTheme = storedTheme === 'light' || storedTheme === 'dark'
      ? storedTheme
      : prefersLightScheme ? 'light' : 'dark';

    const state = {
      imageSource: null,
      imageElement: null,
      imageData: null,
      redrawHandle: null,
      viewMode: 'vector',
      theme: initialTheme,
      levels: 4,
      strokeWeights: [],
      canvasWidth: 0,
      canvasHeight: 0,
      bitmapWidth: 0,
      bitmapHeight: 0,
      pixelRatio: window.devicePixelRatio || 1,
      canvasAspectRatio: 1,
      lastSegments: [],
      lastStrokeCap: 'round',
      lastDimensions: { width: 0, height: 0 }
    };

    const inputs = {
      file: document.getElementById('image-input'),
      blur: document.getElementById('blur-radius'),
      contrast: document.getElementById('contrast'),
      levels: document.getElementById('levels'),
      directionDegrees: document.getElementById('direction-degrees'),
      lineSpacing: document.getElementById('line-spacing'),
      segmentLength: document.getElementById('segment-length'),
      strokeCap: document.getElementById('stroke-cap'),
      strokeWeightsContainer: document.getElementById('stroke-weights'),
      viewToggleButton: document.getElementById('view-toggle'),
      themeToggle: document.getElementById('theme-toggle'),
      copyButton: document.getElementById('copy-svg')
    };

    function scheduleRedraw() {
      if (!state.imageData) {
        return;
      }
      if (state.redrawHandle) {
        cancelAnimationFrame(state.redrawHandle);
      }
      state.redrawHandle = requestAnimationFrame(() => {
        state.redrawHandle = null;
        drawStrokeRaster();
      });
    }

    function clampLevels(value) {
      if (!Number.isFinite(value)) {
        return state.levels || 4;
      }
      return Math.min(10, Math.max(2, Math.round(value)));
    }

    function applyContrast(brightness, boost) {
      return Math.min(1, Math.max(0, 0.5 + (brightness - 0.5) * (1 + boost)));
    }

    function blurBrightnessValues(values, width, height, radius) {
      if (!Number.isFinite(radius) || radius <= 0) {
        return values;
      }

      radius = Math.min(50, Math.floor(radius));
      if (radius <= 0) {
        return values;
      }

      const windowSize = radius * 2 + 1;
      const totalPixels = values.length;
      const horizontal = new Float32Array(totalPixels);
      const blurred = new Float32Array(totalPixels);

      for (let y = 0; y < height; y++) {
        const rowOffset = y * width;
        let sum = 0;
        for (let x = -radius; x <= radius; x++) {
          const clampedX = Math.min(width - 1, Math.max(0, x));
          sum += values[rowOffset + clampedX];
        }
        for (let x = 0; x < width; x++) {
          horizontal[rowOffset + x] = sum / windowSize;
          const removeIndex = rowOffset + Math.max(0, x - radius);
          const addIndex = rowOffset + Math.min(width - 1, x + radius + 1);
          sum += values[addIndex] - values[removeIndex];
        }
      }

      for (let x = 0; x < width; x++) {
        let sum = 0;
        for (let y = -radius; y <= radius; y++) {
          const clampedY = Math.min(height - 1, Math.max(0, y));
          sum += horizontal[clampedY * width + x];
        }
        for (let y = 0; y < height; y++) {
          const index = y * width + x;
          blurred[index] = sum / windowSize;
          const removeY = Math.max(0, y - radius);
          const addY = Math.min(height - 1, y + radius + 1);
          sum += horizontal[addY * width + x] - horizontal[removeY * width + x];
        }
      }

      return blurred;
    }

    function updateStrokeWeightInputs(levels) {
      console.log('Updating stroke weight inputs for levels:', levels);
      const container = inputs.strokeWeightsContainer;
      console.log('Container:', container);
      container.innerHTML = '';
      const existing = Array.isArray(state.strokeWeights) ? state.strokeWeights : [];
      const shouldRebaseline = levels > existing.length;
      const newWeights = [];

      for (let i = 0; i < levels; i++) {
        const targetDefault = Math.max(1, levels - i);
        const defaultWeight = shouldRebaseline
          ? targetDefault
          : Number.isFinite(existing[i])
            ? existing[i]
            : targetDefault;

        const numberControl = document.createElement('div');
        numberControl.className = 'number-control';

        const numberInput = document.createElement('div');
        numberInput.className = 'number-input';

        const minusBtn = document.createElement('button');
        minusBtn.type = 'button';
        minusBtn.className = 'number-btn minus';
        minusBtn.textContent = '-';
        minusBtn.dataset.target = `stroke-weight-${i}`;

        const input = document.createElement('input');
        input.type = 'number';
        input.id = `stroke-weight-${i}`;
        input.min = '0';
        input.step = '1';
        input.value = defaultWeight;
        input.dataset.levelIndex = String(i);
        input.setAttribute('aria-label', `Grey level ${i + 1}`);
        input.title = `Grey level ${i + 1}`;
        input.addEventListener('input', handleStrokeWeightInput);
        input.addEventListener('change', handleStrokeWeightInput);

        const plusBtn = document.createElement('button');
        plusBtn.type = 'button';
        plusBtn.className = 'number-btn plus';
        plusBtn.textContent = '+';
        plusBtn.dataset.target = `stroke-weight-${i}`;

        numberInput.appendChild(minusBtn);
        numberInput.appendChild(input);
        numberInput.appendChild(plusBtn);

        numberControl.appendChild(numberInput);
        container.appendChild(numberControl);
        newWeights.push(Math.max(0, defaultWeight));
        
        console.log(`Created GL${i + 1} with buttons targeting stroke-weight-${i}`);
      }

      state.strokeWeights = newWeights;
      console.log('Stroke weights container now has', container.children.length, 'children');
      scheduleRedraw();
    }

    function handleStrokeWeightInput(event) {
      const index = Number(event.target.dataset.levelIndex);
      const value = parseFloat(event.target.value);
      if (!Number.isFinite(index)) {
        return;
      }
      if (!Number.isFinite(value)) {
        return;
      }
      const clamped = Math.max(0, value);
      state.strokeWeights[index] = clamped;
      if (event.type === 'change') {
        event.target.value = clamped;
      }
      scheduleRedraw();
    }

    function handleLevelsChange(event) {
      const rawValue = inputs.levels.value;
      if (rawValue === '') {
        return;
      }

      const parsed = parseInt(rawValue, 10);
      if (!Number.isFinite(parsed)) {
        return;
      }

      if (event?.type === 'input' && parsed < 2) {
        return;
      }

      const levels = clampLevels(parsed);
      inputs.levels.value = levels;
      if (levels !== state.levels) {
        state.levels = levels;
      }
      updateStrokeWeightInputs(levels);
      redrawImageData();
    }

    state.levels = clampLevels(parseInt(inputs.levels.value, 10) || 4);
    inputs.levels.value = state.levels;
    updateStrokeWeightInputs(state.levels);

    function updateViewToggleButton() {
      const pressed = state.viewMode === 'raster';
      inputs.viewToggleButton.classList.toggle('is-raster', pressed);
      inputs.viewToggleButton.setAttribute('aria-pressed', String(pressed));
    }

    function applyTheme(theme) {
      const resolved = theme === 'light' ? 'light' : 'dark';
      document.body.classList.remove('theme-light', 'theme-dark');
      document.body.classList.add(`theme-${resolved}`);
      state.theme = resolved;
      const isLight = resolved === 'light';
      inputs.themeToggle.textContent = isLight ? 'Dark Mode' : 'Light Mode';
      inputs.themeToggle.setAttribute('aria-pressed', String(isLight));
      localStorage.setItem('strokeRasterTheme', resolved);
    }

    function updateCanvasAspectRatio(width, height) {
      const ratio = Number.isFinite(width) && Number.isFinite(height) && height > 0
        ? Math.max(0.1, width / height)
        : 1;
      state.canvasAspectRatio = ratio;
      if (canvasWrapper) {
        canvasWrapper.style.setProperty('--canvas-aspect', String(ratio));
        canvasWrapper.style.aspectRatio = String(ratio);
      }
    }

    function loadImage(file) {
      const reader = new FileReader();
      reader.addEventListener('load', (event) => {
        setImageSource(event.target.result);
      });
      reader.readAsDataURL(file);
    }

    function setImageSource(source) {
      state.imageSource = source;
      loadImageElement();
    }

    function loadImageElement() {
      if (!state.imageSource) {
        return;
      }

      const image = new Image();
      if (typeof state.imageSource === 'string' && /^https?:\/\//i.test(state.imageSource)) {
        image.crossOrigin = 'anonymous';
      }

      image.onload = () => {
        state.imageElement = image;
        updateCanvasAspectRatio(image.naturalWidth, image.naturalHeight);
        adjustCanvasSize();
      };

      image.onerror = () => {
        console.error('Failed to load image:', state.imageSource);
        state.imageElement = null;
        state.imageData = null;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        updateCanvasAspectRatio(1, 1);
      };

      image.src = state.imageSource;
    }

    function redrawImageData() {
      if (!state.imageElement) {
        return;
      }

      const fallbackRect = (canvasWrapper || canvas).getBoundingClientRect();
      const cssWidth = Math.max(1, Math.round(state.canvasWidth || fallbackRect.width || 1));
      const cssHeight = Math.max(1, Math.round(state.canvasHeight || fallbackRect.height || 1));
      const dpr = state.pixelRatio || window.devicePixelRatio || 1;
      const width = Math.max(1, Math.round((state.bitmapWidth || cssWidth * dpr)));
      const height = Math.max(1, Math.round((state.bitmapHeight || cssHeight * dpr)));

      if (!width || !height) {
        return;
      }

      if (imageCanvas.width !== width || imageCanvas.height !== height) {
        imageCanvas.width = width;
        imageCanvas.height = height;
      }

      imageCtx.setTransform(1, 0, 0, 1, 0, 0);
      imageCtx.clearRect(0, 0, width, height);

      const blurRadius = Math.max(0, Math.round(parseFloat(inputs.blur.value) || 0));

      const { width: imgW, height: imgH } = state.imageElement;
      const scale = Math.min(cssWidth / imgW, cssHeight / imgH);
      const drawWidth = Math.round(imgW * scale * dpr);
      const drawHeight = Math.round(imgH * scale * dpr);
      const dx = Math.round((cssWidth * dpr - drawWidth) / 2);
      const dy = Math.round((cssHeight * dpr - drawHeight) / 2);

      imageCtx.fillStyle = '#fff';
      imageCtx.fillRect(0, 0, width, height);
      imageCtx.drawImage(state.imageElement, dx, dy, drawWidth, drawHeight);

      let imageData;
      try {
        imageData = imageCtx.getImageData(0, 0, width, height);
      } catch (error) {
        console.error('Unable to read image pixels. If the image is remote, ensure it allows CORS.', error);
        state.imageData = null;
        ctx.clearRect(0, 0, width, height);
        return;
      }

      const sourceData = imageData.data;
      const brightness = new Float32Array(width * height);
      for (let i = 0, j = 0; i < sourceData.length; i += 4, j++) {
        const r = sourceData[i] / 255;
        const g = sourceData[i + 1] / 255;
        const b = sourceData[i + 2] / 255;
        brightness[j] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
      }

      const blurredBrightness = blurRadius > 0
        ? blurBrightnessValues(brightness, width, height, blurRadius * dpr)
        : brightness;

      const levels = state.levels || clampLevels(parseInt(inputs.levels.value, 10) || 4);
      state.levels = levels;
      inputs.levels.value = levels;
      const contrastBoost = Math.max(0, parseFloat(inputs.contrast.value) || 0);
      const levelMax = Math.max(1, levels - 1);

      const data = imageData.data;

      for (let j = 0, i = 0; j < blurredBrightness.length; j++, i += 4) {
        const adjusted = applyContrast(blurredBrightness[j], contrastBoost);
        const levelIndex = Math.min(levelMax, Math.max(0, Math.round(adjusted * levelMax)));
        const quantBrightness = levelMax === 0 ? 0 : levelIndex / levelMax;
        const value = Math.round(quantBrightness * 255);
        data[i] = data[i + 1] = data[i + 2] = value;
      }

      imageCtx.putImageData(imageData, 0, 0);
      state.imageData = imageData;
      scheduleRedraw();
    }

    function adjustCanvasSize() {
      if (!canvasWrapper) {
        return;
      }

      const aspect = state.canvasAspectRatio > 0 ? state.canvasAspectRatio : 1;
      const host = canvasWrapper.closest('.preview-pane') || canvasWrapper.parentElement || canvasWrapper;
      const hostRect = host?.getBoundingClientRect();
      const availableWidth = Math.max(1, Math.round(hostRect?.width || canvasWrapper.offsetWidth || 1));
      const viewportCap = Math.max(200, Math.round(window.innerHeight * 0.5));

      let targetWidth = availableWidth;
      let targetHeight = Math.round(targetWidth / aspect) || 1;

      if (targetHeight > viewportCap) {
        targetHeight = viewportCap;
        targetWidth = Math.round(targetHeight * aspect) || targetWidth;
      }

      targetWidth = Math.max(1, targetWidth);
      targetHeight = Math.max(1, targetHeight);

      canvasWrapper.style.width = `${targetWidth}px`;
      canvasWrapper.style.height = `${targetHeight}px`;

      const rect = canvasWrapper.getBoundingClientRect();
      const cssWidth = Math.max(1, Math.round(rect.width));
      const cssHeight = Math.max(1, Math.round(rect.height));
      const dpr = window.devicePixelRatio || 1;
      const bitmapWidth = Math.max(1, Math.round(cssWidth * dpr));
      const bitmapHeight = Math.max(1, Math.round(cssHeight * dpr));

      if (canvas.width !== bitmapWidth || canvas.height !== bitmapHeight) {
        canvas.width = bitmapWidth;
        canvas.height = bitmapHeight;
      }

      state.canvasWidth = cssWidth;
      state.canvasHeight = cssHeight;
      state.bitmapWidth = bitmapWidth;
      state.bitmapHeight = bitmapHeight;
      state.pixelRatio = dpr;

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
      redrawImageData();
    }

    function sampleBrightness(x, y) {
      if (!state.imageData) {
        return 1;
      }
      const width = state.imageData.width;
      const height = state.imageData.height;
      const scale = state.pixelRatio || 1;
      const ix = Math.min(width - 1, Math.max(0, Math.round(x * scale)));
      const iy = Math.min(height - 1, Math.max(0, Math.round(y * scale)));
      const index = (iy * width + ix) * 4;
      const data = state.imageData.data;
      return data[index] / 255;
    }

    function drawStrokeRaster() {
      if (!state.imageData) {
        return;
      }

      const width = state.canvasWidth || canvas.width;
      const height = state.canvasHeight || canvas.height;
      const lineSpacing = Math.max(1, parseFloat(inputs.lineSpacing.value) || 8);
      const segmentLength = Math.max(1, parseFloat(inputs.segmentLength.value) || 12);
      const directionDegrees = Number.isFinite(parseFloat(inputs.directionDegrees.value))
        ? parseFloat(inputs.directionDegrees.value)
        : 0;
      const strokeCap = inputs.strokeCap?.value === 'butt' ? 'butt' : 'round';

      const segments = mergeStrokeSegments(
        collectSegments({
          width,
          height,
          lineSpacing,
          segmentLength,
          directionDegrees,
          strokeWeights: state.strokeWeights,
          levels: state.levels
        })
      );

      state.lastSegments = segments;
      state.lastStrokeCap = strokeCap;
      state.lastDimensions = { width, height };

      ctx.clearRect(0, 0, width, height);

      if (state.viewMode === 'raster') {
        ctx.drawImage(
          imageCanvas,
          0,
          0,
          state.canvasWidth,
          state.canvasHeight
        );
        return;
      }

      ctx.lineJoin = strokeCap === 'butt' ? 'miter' : 'round';
      ctx.lineCap = strokeCap;
      ctx.strokeStyle = '#111';

      for (const segment of segments) {
        ctx.lineWidth = segment.thickness;
        ctx.beginPath();
        ctx.moveTo(segment.x0, segment.y0);
        ctx.lineTo(segment.x1, segment.y1);
        ctx.stroke();
      }
    }

    function mergeStrokeSegments(segments) {
      if (!segments?.length) {
        return segments || [];
      }

      const merged = [];
      const EPS_DISTANCE = 1e-3;
      const EPS_THICKNESS = 1e-3;
      const EPS_DIRECTION = 1e-6;

      let current = { ...segments[0] };

      for (let index = 1; index < segments.length; index++) {
        const next = segments[index];

        if (!next) {
          continue;
        }

        const sameThickness = Math.abs(next.thickness - current.thickness) <= EPS_THICKNESS;

        const dxCurrent = current.x1 - current.x0;
        const dyCurrent = current.y1 - current.y0;
        const dxNext = next.x1 - next.x0;
        const dyNext = next.y1 - next.y0;
        const lenCurrent = Math.hypot(dxCurrent, dyCurrent);
        const lenNext = Math.hypot(dxNext, dyNext);
        const directionalDenominator = Math.max(lenCurrent * lenNext, EPS_DIRECTION);
        const cross = dxCurrent * dyNext - dyCurrent * dxNext;
        const dot = dxCurrent * dxNext + dyCurrent * dyNext;
        const sameDirection = Math.abs(cross) <= EPS_DIRECTION * directionalDenominator && dot >= 0;

        const gap = Math.hypot(current.x1 - next.x0, current.y1 - next.y0);
        const contiguous = gap <= EPS_DISTANCE;

        if (sameThickness && sameDirection && contiguous) {
          current = {
            x0: current.x0,
            y0: current.y0,
            x1: next.x1,
            y1: next.y1,
            thickness: current.thickness
          };
          continue;
        }

        merged.push(current);
        current = { ...next };
      }

      merged.push(current);
      return merged;
    }

    function clipLineAgainstRect(px, py, dx, dy, width, height) {
      const EPS = 1e-6;
      let tMin = -Infinity;
      let tMax = Infinity;

      const checks = [
        { p: -dx, q: px },
        { p: dx, q: width - px },
        { p: -dy, q: py },
        { p: dy, q: height - py }
      ];

      for (const { p, q } of checks) {
        if (Math.abs(p) < EPS) {
          if (q < 0) {
            return null;
          }
          continue;
        }
        const t = q / p;
        if (p < 0) {
          if (t > tMin) {
            tMin = t;
          }
        } else {
          if (t < tMax) {
            tMax = t;
          }
        }
      }

      if (tMin > tMax) {
        return null;
      }

      if (!isFinite(tMin) || !isFinite(tMax)) {
        const corners = [
          [0, 0],
          [width, 0],
          [0, height],
          [width, height]
        ];
        let minProj = Infinity;
        let maxProj = -Infinity;
        for (const [cx, cy] of corners) {
          const proj = (cx - px) * dx + (cy - py) * dy;
          if (proj < minProj) {
            minProj = proj;
          }
          if (proj > maxProj) {
            maxProj = proj;
          }
        }
        if (minProj === Infinity || maxProj === -Infinity) {
          return null;
        }
        tMin = minProj;
        tMax = maxProj;
      }

      return [tMin, tMax];
    }

    function collectSegments({
      width,
      height,
      lineSpacing,
      segmentLength,
      directionDegrees,
      strokeWeights,
      levels
    }) {
      const segments = [];
      const weights = Array.isArray(strokeWeights) && strokeWeights.length > 0
        ? strokeWeights
        : [1];
      const levelsCount = Math.max(2, levels || weights.length || 2);
      const maxLevelIndex = levelsCount - 1;

      const angle = ((Number.isFinite(directionDegrees) ? directionDegrees : 0) % 360 + 360) % 360;
      const radians = angle * Math.PI / 180;
      const dirX = Math.cos(radians);
      const dirY = Math.sin(radians);

      const dirLength = Math.hypot(dirX, dirY);
      if (dirLength === 0) {
        return segments;
      }

      const step = Math.max(0.1, segmentLength);
      const spacing = Math.max(0.5, lineSpacing);
      const ux = dirX / dirLength;
      const uy = dirY / dirLength;
      const nx = -uy;
      const ny = ux;
      const centerX = width / 2;
      const centerY = height / 2;
      const span = Math.abs(nx) * width + Math.abs(ny) * height;
      const lineCount = Math.ceil(span / spacing) + 4;

      for (let i = -lineCount; i <= lineCount; i++) {
        const offset = i * spacing;
        const baseX = centerX + nx * offset;
        const baseY = centerY + ny * offset;
        const bounds = clipLineAgainstRect(baseX, baseY, ux, uy, width, height);
        if (!bounds) {
          continue;
        }

        let [tMin, tMax] = bounds;
        if (!isFinite(tMin) || !isFinite(tMax) || tMax <= tMin) {
          continue;
        }

        let t = tMin;
        while (t < tMax) {
          const tEnd = Math.min(t + step, tMax);
          if (tEnd <= t) {
            break;
          }
          const mid = t + (tEnd - t) * 0.5;
          const sampleX = baseX + ux * mid;
          const sampleY = baseY + uy * mid;
          const brightness = sampleBrightness(sampleX, sampleY);
          const levelIndex = Math.max(0, Math.min(maxLevelIndex, Math.round(brightness * maxLevelIndex)));
          const thickness = weights[levelIndex] ?? weights[weights.length - 1] ?? 1;

          segments.push({
            x0: baseX + ux * t,
            y0: baseY + uy * t,
            x1: baseX + ux * tEnd,
            y1: baseY + uy * tEnd,
            thickness
          });

          t = tEnd;
        }
      }

      return segments;
    }
    inputs.file.addEventListener('change', (event) => {
      const [file] = event.target.files;
      if (file) {
        loadImage(file);
      }
    });

    inputs.directionDegrees.addEventListener('input', scheduleRedraw);
    inputs.directionDegrees.addEventListener('change', scheduleRedraw);
    inputs.lineSpacing.addEventListener('input', scheduleRedraw);
    inputs.lineSpacing.addEventListener('change', scheduleRedraw);
    inputs.segmentLength.addEventListener('input', scheduleRedraw);
    inputs.segmentLength.addEventListener('change', scheduleRedraw);
    if (inputs.strokeCap) {
      inputs.strokeCap.addEventListener('change', scheduleRedraw);
    }

    inputs.blur.addEventListener('input', redrawImageData);
    inputs.blur.addEventListener('change', redrawImageData);
    inputs.contrast.addEventListener('input', redrawImageData);
    inputs.contrast.addEventListener('change', redrawImageData);
    inputs.levels.addEventListener('input', handleLevelsChange);
    inputs.levels.addEventListener('change', handleLevelsChange);
    inputs.viewToggleButton.addEventListener('click', () => {
      state.viewMode = state.viewMode === 'vector' ? 'raster' : 'vector';
      updateViewToggleButton();
      scheduleRedraw();
    });

    inputs.themeToggle.addEventListener('click', () => {
      const nextTheme = state.theme === 'dark' ? 'light' : 'dark';
      applyTheme(nextTheme);
    });

    inputs.copyButton.addEventListener('click', async () => {
      const svg = exportSvg({ download: false });
      if (!svg) {
        return;
      }
      try {
        await navigator.clipboard.writeText(svg);
      } catch (error) {
        console.error('Failed to copy SVG to clipboard:', error);
      }
    });

    // Handle number input buttons - use mousedown instead of click
    document.addEventListener('mousedown', (event) => {
      console.log('Mouse down detected on:', event.target, 'Classes:', event.target.classList);
      if (event.target.classList.contains('number-btn')) {
        console.log('Number button clicked!');
        event.preventDefault();
        event.stopPropagation();
        
        const targetId = event.target.dataset.target;
        console.log('Target ID:', targetId);
        const input = document.getElementById(targetId);
        console.log('Found input:', input);
        if (!input) {
          console.log('Input not found for target:', targetId);
          return;
        }
        
        const isPlus = event.target.classList.contains('plus');
        const currentValue = parseFloat(input.value) || 0;
        const step = parseFloat(input.step) || 1;
        const min = parseFloat(input.min) || -Infinity;
        const max = parseFloat(input.max) || Infinity;
        
        let newValue = isPlus ? currentValue + step : currentValue - step;
        newValue = Math.max(min, Math.min(max, newValue));
        
        console.log('Updating value from', currentValue, 'to', newValue);
        input.value = newValue;
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
      }
    });

    // Handle file input click
    document.querySelector('.upload-link').addEventListener('click', () => {
      inputs.file.click();
    });

    // Debug: Check if static number inputs exist and add individual listeners
    setTimeout(() => {
      console.log('Checking static number inputs...');
      const staticInputs = document.querySelectorAll('input[type="number"]');
      console.log('Found static inputs:', staticInputs);
      staticInputs.forEach((input, index) => {
        console.log(`Input ${index}:`, input.id, input.value);
      });
      
      const allButtons = document.querySelectorAll('.number-btn');
      console.log('Found number buttons:', allButtons);
      allButtons.forEach((btn, index) => {
        console.log(`Button ${index}:`, btn.textContent, btn.dataset.target, btn.classList);
        
        // Add individual click listener for debugging
        btn.addEventListener('click', (e) => {
          console.log('Individual button click detected!', e.target);
          e.stopPropagation();
        });
      });
    }, 2000);

    updateViewToggleButton();
    applyTheme(state.theme);

    window.addEventListener('resize', adjustCanvasSize);

    // Ensure DOM is fully rendered before adjusting canvas
    setTimeout(() => {
      adjustCanvasSize();
      if (DEFAULT_IMAGE) {
        setImageSource(DEFAULT_IMAGE);
      }
    }, 100);

    // Also try to adjust canvas size after a longer delay to ensure it's properly sized
    setTimeout(() => {
      adjustCanvasSize();
    }, 500);

    // Force canvas sizing even without an image
    setTimeout(() => {
      if (!state.imageElement) {
        updateCanvasAspectRatio(500, 400); // Default aspect ratio
        adjustCanvasSize();
      }
    }, 1000);

    document.addEventListener('paste', (event) => {
      const items = event.clipboardData?.items;
      if (!items) {
        return;
      }
      for (const item of items) {
        if (item.kind === 'file' && item.type.startsWith('image/')) {
          const file = item.getAsFile();
          if (file) {
            loadImage(file);
            event.preventDefault();
            return;
          }
        } else if (item.kind === 'string' && item.type === 'text/plain') {
          item.getAsString((text) => {
            if (/^data:image\/[a-zA-Z]+;base64,/.test(text) || /^https?:\/\//i.test(text)) {
              setImageSource(text);
            }
          });
        }
      }
    });

    function exportSvg({ download }) {
      if (!state.lastSegments.length) {
        console.warn('No vector data to export. Ensure the image has been processed.');
        return null;
      }

      const { width, height } = state.lastDimensions;
      if (!width || !height) {
        console.warn('Canvas dimensions unavailable for export.');
        return null;
      }

      const strokeCap = state.lastStrokeCap;
      const precision = (value) => Number.parseFloat(value).toFixed(2);
      const lines = state.lastSegments
        .map((segment) => {
          const x1 = precision(segment.x0);
          const y1 = precision(segment.y0);
          const x2 = precision(segment.x1);
          const y2 = precision(segment.y1);
          const sw = precision(Math.max(0.1, segment.thickness));
          return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke-width="${sw}" />`;
        })
        .join('\n    ');

      const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <g stroke="#111" stroke-linecap="${strokeCap}" fill="none">
    ${lines}
  </g>
</svg>`;

      if (download) {
        const blob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'stroke-raster.svg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      return svg;
    }
  </script>
</body>
</html>
